<style>
  /* Estilos para que se vea bien en Blogger y sea responsive */
  #comic-transcriber-container {
    max-width: 90%;
    margin: 20px auto;
    padding: 20px;
    border: 1px solid #ccc;
    border-radius: 8px;
    background-color: #f9f9f9;
    font-family: sans-serif;
  }
  .input-section, .output-section, .image-preview {
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 6px;
    background-color: #fff;
  }
  .input-section h3, .output-section h3 {
    margin-top: 0;
    color: #333;
    border-bottom: 2px solid #eee;
    padding-bottom: 5px;
  }
  #imageInput {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    display: block;
    width: 100%;
    box-sizing: border-box;
  }
  #extractButton {
    background-color: #4CAF50;
    color: white;
    padding: 10px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    width: 100%;
    transition: background-color 0.3s;
  }
  #extractButton:hover:not(:disabled) {
    background-color: #45a049;
  }
  #extractButton:disabled {
    background-color: #90ee90;
    cursor: not-allowed;
  }
  #outputText {
    width: 100%;
    height: 300px;
    padding: 10px;
    box-sizing: border-box;
    border: 1px solid #ccc;
    border-radius: 4px;
    resize: vertical;
  }
  .download-buttons button {
    background-color: #008CBA;
    color: white;
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 10px;
  }
  .image-preview img {
    max-width: 100px;
    max-height: 100px;
    margin: 5px;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  #loadingMessage {
    color: orange;
    font-weight: bold;
    margin-top: 10px;
  }
</style>

<div id="comic-transcriber-container">
  <h2>Extractor de Texto de Manhuas/Cómics</h2>
  <p>Sube tus imágenes en orden para extraer el texto de la historia.</p>
  
  <div class="input-section">
    <h3>Paso 1: Seleccionar Imágenes</h3>
    <input accept="image/*" id="imageInput" multiple="" type="file" />
  </div>

  <div class="image-preview">
    <h3>Vista Previa de Imágenes Seleccionadas:</h3>
    <div id="previewContainer"></div>
    <p id="imageCount">0 imágenes seleccionadas.</p>
  </div>

  <div class="input-section">
    <h3>Paso 2: Extraer Texto</h3>
    <button disabled="" id="extractButton">Extraer Texto de las Imágenes</button>
    <div id="loadingMessage" style="display: none;">Analizando imágenes con Gemini... Esto puede tomar unos segundos.</div>
  </div>

  <div class="output-section">
    <h3>Paso 3: Resultado del Texto Extraído</h3>
    <textarea id="outputText" placeholder="El texto extraído aparecerá aquí..." readonly=""></textarea>
    <div class="download-buttons" style="margin-top: 10px;">
      <button disabled="" id="downloadTxtButton">Descargar como .TXT</button>
      <button disabled="" id="downloadSrtButton">Descargar como .SRT (Subtítulos)</button>
    </div>
  </div>
</div>

<script>
  // --- CONFIGURACIÓN Y CLAVE API (REEMPLAZA ESTO) ---
  const GEMINI_API_KEY = 'AIzaSyC4CEQQEoYILx4i41IiRBRqFCLuRi4fh6M'; 
  const GEMINI_MODEL = 'gemini-2.5-flash';
  // ----------------------------------------------------

  const imageInput = document.getElementById('imageInput');
  const extractButton = document.getElementById('extractButton');
  const outputText = document.getElementById('outputText');
  const previewContainer = document.getElementById('previewContainer');
  const imageCountDisplay = document.getElementById('imageCount');
  const loadingMessage = document.getElementById('loadingMessage');
  const downloadTxtButton = document.getElementById('downloadTxtButton');
  const downloadSrtButton = document.getElementById('downloadSrtButton');

  // Función de ayuda para convertir el archivo de imagen a base64
  function fileToGenerativePart(file) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        resolve({
          inlineData: {
            data: reader.result.split(',')[1],
            mimeType: file.type,
          },
        });
      };
      reader.readAsDataURL(file);
    });
  }

  // Actualiza la vista previa y habilita/deshabilita el botón de extracción
  imageInput.addEventListener('change', () => {
    previewContainer.innerHTML = '';
    const files = Array.from(imageInput.files);
    
    imageCountDisplay.textContent = `${files.length} imágenes seleccionadas.`;
    extractButton.disabled = files.length === 0;
    outputText.value = '';
    downloadTxtButton.disabled = true;
    downloadSrtButton.disabled = true;

    files.forEach(file => {
      const img = document.createElement('img');
      img.src = URL.createObjectURL(file);
      img.alt = file.name;
      previewContainer.appendChild(img);
    });
  });

  // Función principal para la extracción
  extractButton.addEventListener('click', async () => {
    const files = Array.from(imageInput.files);
    if (files.length === 0) return;

    extractButton.disabled = true;
    loadingMessage.style.display = 'block';
    outputText.value = 'Procesando...';
    downloadTxtButton.disabled = true;
    downloadSrtButton.disabled = true;

    try {
      // Convertir archivos a partes generativas
      const imageParts = await Promise.all(files.map(fileToGenerativePart));
      
      // Construir el prompt para Gemini
      const prompt = `Analiza estas ${files.length} imágenes de cómic o manhua en el orden en que se subieron. Extrae todo el texto del diálogo y la narración. Evita cualquier texto de anuncios, nombres de artistas o marcas de agua. Presenta el texto extraído en una lista simple, con cada diálogo o bloque de texto en una nueva línea. No añadas ninguna introducción ni conclusión, solo el texto puro.`;
      
      // Preparar el cuerpo de la solicitud
      const contents = [{
        role: "user",
        parts: [
          ...imageParts,
          { text: prompt }
        ]
      }];

      // Realizar la solicitud a la API de Gemini
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ contents })
      });

      const data = await response.json();

      if (data.candidates && data.candidates.length > 0) {
        const extractedText = data.candidates[0].content.parts[0].text.trim();
        // Limpiar el texto de cualquier formato de lista (como guiones o números) que el modelo pueda agregar
        const cleanText = extractedText
                            .split('\n')
                            .map(line => line.replace(/^(\*|\-|\d+\.|\s*)\s*/, '').trim())
                            .filter(line => line.length > 0)
                            .join('\n');
                            
        outputText.value = cleanText;
        downloadTxtButton.disabled = false;
        downloadSrtButton.disabled = false;
      } else {
        outputText.value = 'Error al extraer el texto. Respuesta inválida de la API.';
      }

    } catch (error) {
      console.error('Error al procesar las imágenes:', error);
      outputText.value = `Error en la solicitud: ${error.message}. Asegúrate de que la Clave API sea correcta.`;
    } finally {
      extractButton.disabled = false;
      loadingMessage.style.display = 'none';
    }
  });
  
  // Función para descargar el texto
  function downloadText(content, filename, type) {
    const blob = new Blob([content], { type: type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Descargar como TXT
  downloadTxtButton.addEventListener('click', () => {
    const content = outputText.value;
    if (content) {
      downloadText(content, 'texto_extraido.txt', 'text/plain');
    }
  });

  // Descargar como SRT (genera un formato de subtítulo básico)
  downloadSrtButton.addEventListener('click', () => {
    const lines = outputText.value.split('\n').filter(line => line.trim() !== '');
    let srtContent = '';
    let timeIndex = 1;
    let timeOffset = 0;
    
    // Generar un SRT con un tiempo ficticio (cada línea dura 2 segundos)
    lines.forEach((line, index) => {
      const start = timeOffset;
      const end = timeOffset + 2000;
      
      const formatTime = (ms) => {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
        const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
        const seconds = String(totalSeconds % 60).padStart(2, '0');
        const milliseconds = String(ms % 1000).padStart(3, '0');
        return `${hours}:${minutes}:${seconds},${milliseconds}`;
      };

      srtContent += `${timeIndex}\n`;
      srtContent += `${formatTime(start)} --> ${formatTime(end)}\n`;
      srtContent += `${line}\n\n`;
      
      timeIndex++;
      timeOffset += 2000; // Incremento de 2 segundos por línea
    });

    if (srtContent) {
      downloadText(srtContent, 'dialogos_extraidos.srt', 'text/srt');
    }
  });
</script>
