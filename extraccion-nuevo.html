<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extractor de Texto (Salida con Tiempos SRT)</title>
    <style>
        /* CSS para el dise침o */
        body { font-family: sans-serif; margin: 0; padding: 20px; background-color: #f0f2f5; }
        #container { max-width: 800px; margin: 0 auto; padding: 30px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); background-color: #ffffff; }
        h2 { color: #1a73e8; border-bottom: 2px solid #e0e0e0; padding-bottom: 5px; margin-bottom: 15px; font-size: 1.8em; }
        .section { margin-bottom: 25px; padding: 20px; border: 1px solid #ddd; border-radius: 8px; background-color: #f9f9f9; }
        #imageInput { padding: 8px; border: 1px solid #ccc; border-radius: 4px; display: block; width: 100%; box-sizing: border-box; }
        #extractButton { background-color: #007bff; color: white; padding: 12px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; width: 100%; transition: background-color 0.3s; }
        #extractButton:disabled { background-color: #a0c3ff; cursor: not-allowed; }
        /* El tama침o de outputText es clave para ver el formato SRT */
        #outputText { width: 100%; min-height: 300px; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; resize: vertical; margin-top: 10px; font-family: monospace; white-space: pre; /* Esto es importante para mostrar el formato SRT */ } 
        #loadingMessage { color: orange; font-weight: bold; margin-top: 10px; display: none; }
        #statusMessage { color: red; font-weight: bold; margin-top: 10px; }
        #previewContainer img { max-width: 70px; margin-right: 5px; border: 1px solid #ddd; border-radius: 4px; }
        #downloadButtons button { margin-top: 10px; padding: 10px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        #downloadButtons button:disabled { background-color: #90ee90; cursor: not-allowed; }
        
        #chapter-links { margin-bottom: 20px; padding: 15px; border: 1px dashed #1a73e8; border-radius: 8px; background-color: #e3f2fd; }
    </style>
</head>
<body>

<div id="container">
    <h2>Extractor de Texto (Salida con Tiempos SRT)</h2>
    <p>El 치rea de texto ahora muestra el formato de subt칤tulos SRT (incluyendo las marcas de tiempo).</p>
    
    <div id="chapter-links">
        <h3>游댕 Enlaces Guardados (Cap칤tulo 486)</h3>
        <p>Los enlaces se almacenar칤an aqu칤. C칩digo de ajuste recordado: `[El c칩digo de ajuste anterior]`.</p>
        <p>Ejemplo de enlaces: <a href="[Link 1]" target="_blank">P치gina 1</a>, <a href="[Link 2]" target="_blank">P치gina 2</a>...</p>
    </div>

    <div class="section">
        <h3>1. Seleccionar Im치genes</h3>
        <input type="file" id="imageInput" accept="image/*" multiple>
        <div id="previewContainer" style="margin-top:10px;"></div>
        <p id="imageCount">0 im치genes seleccionadas.</p>
    </div>

    <div class="section">
        <h3>2. Extraer Texto</h3>
        <button id="extractButton" disabled>Extraer Texto de las Im치genes</button>
        <div id="loadingMessage">Comprimiendo y analizando im치genes con Gemini...</div>
        <p id="statusMessage" style="color:red; font-weight:bold;"></p>
    </div>
    
    <div class="section">
        <h3>3. Resultado (Formato SRT)</h3>
        <textarea id="outputText" readonly placeholder="El texto extra칤do aparecer치 aqu칤 en formato SRT..."></textarea>
        <div id="downloadButtons">
            <button id="downloadTexButton" disabled>Descargar como .tex (Solo Texto)</button> 
            <button id="downloadSrtButton" disabled>Descargar como .srt (Formato de Subt칤tulos)</button>
        </div>
    </div>
</div>

<script>
    // --- CLAVE API INTEGRADA ---
    const GEMINI_API_KEY = 'AIzaSyAXCJ2b4aTfO1TWCLly8iyiD1c622n7N3E'; 
    const GEMINI_MODEL = 'gemini-2.5-flash';
    // --------------------------

    const outputText = document.getElementById('outputText');
    const imageInput = document.getElementById('imageInput');
    const extractButton = document.getElementById('extractButton');
    const previewContainer = document.getElementById('previewContainer');
    const imageCountDisplay = document.getElementById('imageCount');
    const loadingMessage = document.getElementById('loadingMessage');
    const statusMessage = document.getElementById('statusMessage');
    const downloadTexButton = document.getElementById('downloadTexButton');
    const downloadSrtButton = document.getElementById('downloadSrtButton');
    let extractedTextGlobal = ""; 
    let srtContentGlobal = ""; // Nuevo para guardar el SRT completo


    // --- FUNCIONES DE DESCARGA (SRT con c치lculo de lectura) ---

    function downloadFile(content, fileName, mimeType) {
        const a = document.createElement('a');
        const blob = new Blob([content], { type: mimeType });
        a.href = URL.createObjectURL(blob);
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    // Esta funci칩n ahora genera el formato SRT y lo devuelve.
    function generateSrtContent(text, formatOutput = false) {
        const lines = text.split('\n').filter(line => line.trim() !== '');
        let srtContent = '';
        let sequence = 1;
        let totalTimeMs = 0;
        
        // C츼LCULO DE VELOCIDAD DE LECTURA: 160 WPM => 375 ms por palabra
        const MS_PER_WORD = 375; 
        const MIN_DURATION_MS = 1500; 
        const MAX_DURATION_MS = 6000; 

        function formatTime(ms) {
            const date = new Date(ms);
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            const seconds = String(date.getUTCSeconds()).padStart(2, '0');
            const milliseconds = String(date.getUTCMilliseconds()).padStart(3, '0');
            return `${hours}:${minutes}:${seconds},${milliseconds}`;
        }

        for (const line of lines) {
            const wordCount = line.split(/\s+/).length;
            let calculatedDuration = wordCount * MS_PER_WORD;
            
            if (calculatedDuration < MIN_DURATION_MS) {
                calculatedDuration = MIN_DURATION_MS;
            } else if (calculatedDuration > MAX_DURATION_MS) {
                calculatedDuration = MAX_DURATION_MS;
            }
            
            const startTime = totalTimeMs;
            const endTime = totalTimeMs + calculatedDuration;

            // Formato est치ndar SRT
            srtContent += sequence + '\n';
            srtContent += formatTime(startTime) + ' --> ' + formatTime(endTime) + '\n';
            srtContent += line + '\n\n';

            totalTimeMs = endTime;
            sequence++;
        }
        return srtContent;
    }

    downloadTexButton.addEventListener('click', () => {
        // La descarga .tex usa solo el texto sin marcas de tiempo
        downloadFile(extractedTextGlobal, 'capitulo_extraido.tex', 'text/plain');
    });

    downloadSrtButton.addEventListener('click', () => {
        // La descarga .srt usa el contenido SRT generado
        downloadFile(srtContentGlobal, 'capitulo_extraido.srt', 'text/plain');
    });

    // Funci칩n de compresi칩n (sin cambios)
    function fileToGenerativePart(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const MAX_SIZE = 1600; 
                    const QUALITY = 0.7;    
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > MAX_SIZE) { height *= MAX_SIZE / width; width = MAX_SIZE; }
                    } else {
                        if (height > MAX_SIZE) { height *= MAX_SIZE / height; height = MAX_SIZE; }
                    }

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0, width, height);

                    const compressedDataURL = canvas.toDataURL('image/jpeg', QUALITY);
                    
                    resolve({
                        inlineData: {
                            data: compressedDataURL.split(',')[1],
                            mimeType: 'image/jpeg', 
                        },
                    });
                };
                img.onerror = reject;
                img.src = event.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    imageInput.addEventListener('change', () => {
        previewContainer.innerHTML = '';
        const files = Array.from(imageInput.files);
        imageCountDisplay.textContent = `${files.length} im치genes seleccionadas.`;
        extractButton.disabled = files.length === 0;
        statusMessage.textContent = ''; 
        downloadTexButton.disabled = true;
        downloadSrtButton.disabled = true;
        
        files.forEach(file => {
            const img = document.createElement('img');
            img.src = URL.createObjectURL(file);
            previewContainer.appendChild(img);
        });
    });

    // FUNCI칍N PRINCIPAL DE EXTRACCI칍N
    extractButton.addEventListener('click', async () => {
        const files = Array.from(imageInput.files);
        if (files.length === 0) return;

        extractButton.disabled = true;
        downloadTexButton.disabled = true;
        downloadSrtButton.disabled = true;
        loadingMessage.style.display = 'block';
        outputText.value = 'Comprimiendo y enviando a Gemini...';
        statusMessage.textContent = ''; 
        extractedTextGlobal = ""; 
        srtContentGlobal = "";

        try {
            const imageParts = await Promise.all(files.map(fileToGenerativePart));
            outputText.value = 'Solicitud enviada. Esperando respuesta...';
            
            const prompt = `Analiza estas ${files.length} im치genes de c칩mic o manhua en orden. Tu 칰nica tarea es extraer el di치logo de los globos y la narraci칩n de las cajas de texto que forman parte de la historia. Ignora completamente y NO incluyas: nombres de artistas, marcas de agua, n칰meros de p치gina, cr칠ditos, anuncios, texto de pie de p치gina o cualquier texto que no sea del argumento central. Presenta el texto extra칤do en una lista simple, una frase o bloque por l칤nea. No a침adas introducci칩n, solo el texto puro.`;
            
            const contents = [{
                role: "user",
                parts: [...imageParts, { text: prompt }]
            }];

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: contents }) 
            });

            const data = await response.json();

            if (response.status !== 200 || !data.candidates || data.candidates.length === 0) {
                let errorMsg = `Error de la API (Estado: ${response.status}). `;

                if (data.promptFeedback && data.promptFeedback.blockReason) {
                    errorMsg += `**BLOQUEADO POR SEGURIDAD:** ${data.promptFeedback.blockReason}.`;
                } else if (data.error && data.error.message) {
                    errorMsg += `Mensaje de error: ${data.error.message}.`;
                } else if (response.status === 200) {
                    errorMsg = "Error: Respuesta exitosa (200) pero contenido vac칤o.";
                }
                
                statusMessage.textContent = errorMsg;
                outputText.value = 'Fallo al extraer el texto. Revisa el mensaje de error.';
                return; 
            }
            
            // 1. Obtener el texto extra칤do y limpiarlo
            extractedTextGlobal = data.candidates[0].content.parts[0].text.trim();
            const cleanText = extractedTextGlobal
                                .split('\n')
                                .map(line => line.replace(/^(\*|\-|\d+\.|\s*)\s*/, '').trim())
                                .filter(line => line.length > 0)
                                .join('\n');
            
            // 2. Generar el contenido SRT con marcas de tiempo
            srtContentGlobal = generateSrtContent(cleanText);

            // 3. Mostrar el formato SRT completo en la pantalla
            outputText.value = srtContentGlobal;

            // 4. Guardar la versi칩n solo de texto para la descarga .tex
            extractedTextGlobal = cleanText; 

            downloadTexButton.disabled = false;
            downloadSrtButton.disabled = false;

        } catch (error) {
            statusMessage.textContent = `Error de red: ${error.message}. Aseg칰rate de estar conectado.`;
            outputText.value = 'Fallo en la conexi칩n.';
        } finally {
            extractButton.disabled = false;
            loadingMessage.style.display = 'none';
        }
    });
</script>

</body>
</html>